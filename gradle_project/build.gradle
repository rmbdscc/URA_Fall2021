buildscript {
    repositories {
        mavenCentral()
        // Similar to the JCP example, let's not put the plugin directory inside this projec, i.e. "../../xxxx".
        flatDir dirs: "./build/libs"
    }
    dependencies {
        classpath 'com.igormaznitsa:jcp:7.0.5'
        classpath 'plugin:plugin:0.1.1-SNAPSHOT'
    }
}

plugins {
    id 'java-library'
}

//apply plugin: 'java'
apply plugin: 'application'
apply plugin: 'com.igormaznitsa.jcp'
apply plugin: 'me.champeau.mrjar'

group 'org.example'
version '1.0-SNAPSHOT'

mainClassName = 'java.HelloWorld'

java {
    toolchain {
        // is this necessary?
        languageVersion.set(JavaLanguageVersion.of(8))
    }
}

repositories {
    mavenLocal()
    mavenCentral()
}

multiRelease {
    // why is there two 8s?
    targetVersions "build/jcp/", "build/jcp/", 8, 8, 11
}

dependencies {
    // note: I think we don't need to add this part to the checker framework.
    implementation 'org.codehaus.groovy:groovy-all:3.0.5'
    testImplementation 'org.junit.jupiter:junit-jupiter-api:5.7.0'
    testRuntimeOnly 'org.junit.jupiter:junit-jupiter-engine:5.7.0'
}

test {
    useJUnitPlatform()
}

jar {
    // added duplicatesStrategy to avoid warning messages
    // let's try if we can remote this DuplicatesStrategy
    duplicatesStrategy = DuplicatesStrategy.EXCLUDE

    // I thought mr-jars should handle this automatically. no?
    into('META-INF/versions/11') {
        from sourceSets.java11.output
    }
    manifest.attributes(
            'Multi-Release': 'true',
            'Main-Class': 'Main'
    )
    archiveBaseName = 'mutli-release'
}

// instead of having one task per java version, let's iterate through a list of
// java versions, and programmatically register one new task per java version.
// ref: https://docs.gradle.org/current/userguide/tutorial_using_tasks.html#sec:dynamic_tasks
task compileWithJava8 (type: com.igormaznitsa.jcp.gradle.JcpTask) {
    // note: printlns were here for debugging
    println "executing compileWithJava8"
    println sourceSets.main.java.srcDirs

    def java_dir = 'build/jcp/java'
    outputs.dir(java_dir)
    sources = sourceSets.main.java.srcDirs

    vars = [currentJava: '8']
    target = new File(java_dir)
    doLast{
        println("Incoming preprocess files: " + incomingFiles.size())
        println("Resulted preprocess files: " + outcomingFiles.size())
    }

}

task compileWithJava11 (type: com.igormaznitsa.jcp.gradle.JcpTask) {
    // note: printlns were here for debugging
    println "executing compileWithJava11"
    println sourceSets.main.java.srcDirs

    def java_dir = 'build/jcp/java11'

    outputs.dir(java_dir)
    sources = sourceSets.main.java.srcDirs

    vars = [currentJava: '11']
    target = new File(java_dir)

    doLast{
        println("Incoming preprocess files: " + incomingFiles.size())
        println("Resulted preprocess files: " + outcomingFiles.size())
    }

}

task changeSourceFolder() {
    doLast{
        sourceSets.main.java.srcDirs = ["build/jcp/java"]
    }
}

import java.security.MessageDigest;
import java.nio.file.Files;
import java.nio.file.Paths;
task deleteDuplicatedFiles(){

    doLast {

        // get all directories just below the jcp directory
        File dir = new File("build/jcp")
        
        // why not just directories = Arrays.sort(new File("build/jcp").listFiles(fileFilter))
        
        File[] directories = new File("build/jcp").listFiles()
        FileFilter fileFilter = new FileFilter() {
            public boolean accept(File file) {
                return file.isDirectory();
            }
        }
        directories = dir.listFiles(fileFilter);
        // stored the directories in alphabetical order
        Arrays.sort(directories)

        Map<String, String> fileMap = new HashMap<>()
        for(String directory : directories){

            fileTree(dir: directory).visit { FileVisitDetails fvd ->
                if(fvd.file.isFile()) {
                    // calculate the MD5 hash for the file
                    byte[] fileContent = Files.readAllBytes(Paths.get(fvd.file.toString()));
                    String relativePath = fvd.getRelativePath()
                    String hashString = MessageDigest.getInstance("MD5").digest(fileContent).toString();

                    if(fileMap.containsKey(relativePath)){
                        if(fileMap.get(relativePath).equals(hashString)){
                            println ("found duplicated file: " + fvd.file)
                            project.delete(files(fvd.file))
                        }
                    } else {
                        fileMap.put(relativePath, hashString)
                    }
                }
            }
        }
    }
}

compileWithJava8.dependsOn(compileWithJava11)
deleteDuplicatedFiles.dependsOn compileWithJava8
changeSourceFolder.dependsOn deleteDuplicatedFiles
compileJava.dependsOn changeSourceFolder



